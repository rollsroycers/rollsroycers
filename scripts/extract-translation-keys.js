#!/usr/bin/env node

/**
 * ุฃุฏุงุฉ ุดุงููุฉ ูุงุณุชุฎุฑุงุฌ ุฌููุน ููุงุชูุญ ุงูุชุฑุฌูุฉ ูู ุงูููุฏ ูููุงุฑูุชูุง ูุน ูููุงุช JSON
 * ูุชุญุฏูุฏ ุงูููุงุชูุญ ุงูููููุฏุฉ ููุดุงูู ุงูุจููุฉ
 */

const fs = require('fs');
const path = require('path');
const glob = require('glob');

/**
 * ุงุณุชุฎุฑุงุฌ ููุงุชูุญ ุงูุชุฑุฌูุฉ ูู ุงูููุฏ
 */
function extractTranslationKeys() {
  const allKeys = new Set();
  const keysByFile = {};
  
  // ุงูุจุญุซ ุนู ุฌููุน ูููุงุช TypeScript ูJavaScript
  const files = glob.sync('src/**/*.{ts,tsx,js,jsx}', { cwd: process.cwd() });
  
  files.forEach(filePath => {
    const content = fs.readFileSync(filePath, 'utf8');
    const fileKeys = [];
    
    // ุงูุจุญุซ ุนู ุฃููุงุท ูุฎุชููุฉ ูุงุณุชุฎุฏุงู ุงูุชุฑุฌูุฉ
    const patterns = [
      // t('key')
      /t\(['"`]([^'"`]+)['"`]\)/g,
      // t("key")
      /t\(["']([^"']+)["']\)/g,
      // t(`key`)
      /t\(`([^`]+)`\)/g,
      // getTranslatedArray('key')
      /getTranslatedArray\(['"`]([^'"`]+)['"`]\)/g,
      // pageKey="key"
      /pageKey=['"`]([^'"`]+)['"`]/g
    ];
    
    patterns.forEach(pattern => {
      let match;
      while ((match = pattern.exec(content)) !== null) {
        const key = match[1];
        allKeys.add(key);
        fileKeys.push(key);
      }
    });
    
    if (fileKeys.length > 0) {
      keysByFile[filePath] = fileKeys;
    }
  });
  
  return { allKeys: Array.from(allKeys), keysByFile };
}

/**
 * ุชุญููู ูููุงุช ุงูุชุฑุฌูุฉ ุงูููุฌูุฏุฉ
 */
function loadExistingTranslations() {
  const translations = {};
  const localesPath = path.join(__dirname, '..', 'public', 'locales');
  
  if (!fs.existsSync(localesPath)) {
    return translations;
  }
  
  const languages = fs.readdirSync(localesPath);
  
  languages.forEach(lang => {
    const langPath = path.join(localesPath, lang);
    if (!fs.statSync(langPath).isDirectory()) return;
    
    translations[lang] = {};
    
    const files = fs.readdirSync(langPath);
    files.forEach(file => {
      if (file.endsWith('.json')) {
        const namespace = file.replace('.json', '');
        try {
          const content = fs.readFileSync(path.join(langPath, file), 'utf8');
          translations[lang][namespace] = JSON.parse(content);
        } catch (error) {
          console.error(`ุฎุทุฃ ูู ูุฑุงุกุฉ ${file} ููุบุฉ ${lang}:`, error.message);
        }
      }
    });
  });
  
  return translations;
}

/**
 * ูุญุต ูุฌูุฏ ููุชุงุญ ูู ูููุงุช ุงูุชุฑุฌูุฉ
 */
function keyExists(translations, lang, key) {
  if (!translations[lang]) return false;
  
  const parts = key.split('.');
  let current = translations[lang];
  
  // ูุญุต ูู ุฌููุน namespaces
  for (const namespace in current) {
    let obj = current[namespace];
    let found = true;
    
    for (const part of parts) {
      if (obj && obj[part] !== undefined) {
        obj = obj[part];
      } else {
        found = false;
        break;
      }
    }
    
    if (found && typeof obj === 'string') {
      return { namespace, value: obj };
    }
  }
  
  return false;
}

/**
 * ุชุญููู ุงูููุงุชูุญ ุงูููููุฏุฉ
 */
function analyzeMissingKeys(allKeys, translations) {
  const languages = Object.keys(translations);
  const missingKeys = {};
  const suggestions = {};
  
  languages.forEach(lang => {
    missingKeys[lang] = [];
    suggestions[lang] = {};
  });
  
  allKeys.forEach(key => {
    languages.forEach(lang => {
      const exists = keyExists(translations, lang, key);
      if (!exists) {
        missingKeys[lang].push(key);
        
        // ุงูุชุฑุงุญุงุช ููููุงุชูุญ ุงููุดุงุจูุฉ
        const similarKeys = findSimilarKeys(key, translations[lang]);
        if (similarKeys.length > 0) {
          suggestions[lang][key] = similarKeys;
        }
      }
    });
  });
  
  return { missingKeys, suggestions };
}

/**
 * ุงูุจุญุซ ุนู ููุงุชูุญ ูุดุงุจูุฉ
 */
function findSimilarKeys(targetKey, languageTranslations) {
  const allKeys = [];
  
  function extractKeys(obj, prefix = '') {
    for (const key in obj) {
      const fullKey = prefix ? `${prefix}.${key}` : key;
      if (typeof obj[key] === 'object') {
        extractKeys(obj[key], fullKey);
      } else {
        allKeys.push(fullKey);
      }
    }
  }
  
  Object.values(languageTranslations).forEach(namespace => {
    extractKeys(namespace);
  });
  
  // ุงูุจุญุซ ุนู ููุงุชูุญ ูุดุงุจูุฉ ุจูุงุก ุนูู ุงูุชุดุงุจู ุงููุตู
  return allKeys.filter(key => {
    const similarity = calculateSimilarity(targetKey, key);
    return similarity > 0.6; // 60% ุชุดุงุจู
  }).slice(0, 3); // ุฃูุถู 3 ุงูุชุฑุงุญุงุช
}

/**
 * ุญุณุงุจ ุงูุชุดุงุจู ุจูู ูุตูู
 */
function calculateSimilarity(str1, str2) {
  const len1 = str1.length;
  const len2 = str2.length;
  const matrix = Array(len2 + 1).fill().map(() => Array(len1 + 1).fill(0));
  
  for (let i = 0; i <= len1; i++) matrix[0][i] = i;
  for (let j = 0; j <= len2; j++) matrix[j][0] = j;
  
  for (let j = 1; j <= len2; j++) {
    for (let i = 1; i <= len1; i++) {
      if (str1[i - 1] === str2[j - 1]) {
        matrix[j][i] = matrix[j - 1][i - 1];
      } else {
        matrix[j][i] = Math.min(
          matrix[j - 1][i] + 1,
          matrix[j][i - 1] + 1,
          matrix[j - 1][i - 1] + 1
        );
      }
    }
  }
  
  const maxLen = Math.max(len1, len2);
  return (maxLen - matrix[len2][len1]) / maxLen;
}

/**
 * ุงูุชุฑุงุญ ุจููุฉ ุฌุฏูุฏุฉ ูููููุงุช
 */
function suggestFileStructure(allKeys) {
  const structure = {
    'common.json': {
      description: 'ุงููุญุชูู ุงูุนุงู ูุงููุดุชุฑู',
      keys: []
    },
    'seo.json': {
      description: 'ุนูุงููู ุงูุตูุญุงุช ูุงูุฃูุตุงู',
      keys: []
    },
    'navigation.json': {
      description: 'ุนูุงุตุฑ ุงูุชููู ูุงูููุงุฆู',
      keys: []
    },
    'pages.json': {
      description: 'ูุญุชูู ุงูุตูุญุงุช ุงููุญุฏุฏ',
      keys: []
    },
    'services.json': {
      description: 'ูุญุชูู ุงูุฎุฏูุงุช',
      keys: []
    },
    'fleet.json': {
      description: 'ูุนูููุงุช ุงูุณูุงุฑุงุช',
      keys: []
    },
    'locations.json': {
      description: 'ูุนูููุงุช ุงูููุงูุน',
      keys: []
    }
  };
  
  allKeys.forEach(key => {
    if (key.startsWith('pages.') && (key.includes('.title') || key.includes('.description') || key.includes('.keywords'))) {
      structure['seo.json'].keys.push(key);
    } else if (key.startsWith('nav.') || key.includes('.nav')) {
      structure['navigation.json'].keys.push(key);
    } else if (key.startsWith('fleet.') || key.includes('.phantom') || key.includes('.ghost') || key.includes('.cullinan')) {
      structure['fleet.json'].keys.push(key);
    } else if (key.startsWith('services.') || key.startsWith('servicesPages.')) {
      structure['services.json'].keys.push(key);
    } else if (key.startsWith('locations.') || key.includes('downtownDubai') || key.includes('dubaiMarina')) {
      structure['locations.json'].keys.push(key);
    } else if (key.startsWith('pages.') || key.includes('Page.')) {
      structure['pages.json'].keys.push(key);
    } else {
      structure['common.json'].keys.push(key);
    }
  });
  
  return structure;
}

/**
 * ุฅูุดุงุก ุชูุฑูุฑ ุดุงูู
 */
function generateReport() {
  console.log('๐ ุงุณุชุฎุฑุงุฌ ููุงุชูุญ ุงูุชุฑุฌูุฉ ูู ุงูููุฏ...');
  const { allKeys, keysByFile } = extractTranslationKeys();
  
  console.log('๐ ุชุญููู ูููุงุช ุงูุชุฑุฌูุฉ ุงูููุฌูุฏุฉ...');
  const translations = loadExistingTranslations();
  
  console.log('๐ ุชุญููู ุงูููุงุชูุญ ุงูููููุฏุฉ...');
  const { missingKeys, suggestions } = analyzeMissingKeys(allKeys, translations);
  
  console.log('๐๏ธ  ุงูุชุฑุงุญ ุจููุฉ ุฌุฏูุฏุฉ ูููููุงุช...');
  const suggestedStructure = suggestFileStructure(allKeys);
  
  const report = {
    summary: {
      totalKeys: allKeys.length,
      totalFiles: Object.keys(keysByFile).length,
      languages: Object.keys(translations),
      missingKeysCount: Object.values(missingKeys).reduce((sum, keys) => sum + keys.length, 0)
    },
    allKeys: allKeys.sort(),
    keysByFile,
    missingKeys,
    suggestions,
    suggestedStructure,
    currentStructure: Object.keys(translations).reduce((acc, lang) => {
      acc[lang] = Object.keys(translations[lang]);
      return acc;
    }, {})
  };
  
  // ุญูุธ ุงูุชูุฑูุฑ
  const reportPath = path.join(__dirname, '..', 'translation-keys-analysis.json');
  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
  
  console.log('\n๐ ุชูุฑูุฑ ุงูุชุญููู:');
  console.log('โ'.repeat(80));
  console.log(`๐ ุฅุฌูุงูู ุงูููุงุชูุญ ุงููุณุชุฎุฏูุฉ: ${report.summary.totalKeys}`);
  console.log(`๐ ุนุฏุฏ ุงููููุงุช: ${report.summary.totalFiles}`);
  console.log(`๐ ุงููุบุงุช ุงููุฏุนููุฉ: ${report.summary.languages.join(', ')}`);
  console.log(`โ ุงูููุงุชูุญ ุงูููููุฏุฉ: ${report.summary.missingKeysCount}`);
  
  console.log('\nโ ุงูููุงุชูุญ ุงูููููุฏุฉ ููู ูุบุฉ:');
  Object.entries(missingKeys).forEach(([lang, keys]) => {
    if (keys.length > 0) {
      console.log(`\n๐ด ${lang}: ${keys.length} ููุชุงุญ ููููุฏ`);
      keys.slice(0, 10).forEach(key => console.log(`   - ${key}`));
      if (keys.length > 10) {
        console.log(`   ... ู ${keys.length - 10} ููุชุงุญ ุขุฎุฑ`);
      }
    }
  });
  
  console.log('\n๐๏ธ  ุงูุจููุฉ ุงูููุชุฑุญุฉ ูููููุงุช:');
  Object.entries(suggestedStructure).forEach(([file, info]) => {
    console.log(`\n๐ ${file} (${info.keys.length} ููุชุงุญ)`);
    console.log(`   ๐ก ${info.description}`);
    if (info.keys.length > 0) {
      console.log(`   ๐ ุฃูุซูุฉ: ${info.keys.slice(0, 3).join(', ')}`);
    }
  });
  
  console.log(`\n๐พ ุชู ุญูุธ ุงูุชูุฑูุฑ ุงููุงูู ูู: ${reportPath}`);
  
  return report;
}

if (require.main === module) {
  try {
    generateReport();
  } catch (error) {
    console.error('โ ุฎุทุฃ ูู ุชุดุบูู ุงูุชุญููู:', error.message);
    process.exit(1);
  }
}

module.exports = { extractTranslationKeys, loadExistingTranslations, generateReport }; 